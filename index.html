<!doctype html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FUNTIMECHAT ‚Äî Full</title>
  <meta name="description" content="FUNTIMECHAT - Free Chat with public rooms, PMs, random match, calls, friends." />
  <link rel="stylesheet" href="style.css" />
  <style>
    /* minimal helpers */
    .hidden{display:none!important}
    .sr-only{position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    .btn-inline { display:inline-flex; align-items:center; gap:8px; }
  </style>
</head>
<body>

  <!-- Loading -->
  <div id="loading-screen" role="status" aria-live="polite">
    <div class="logo-pulse" aria-hidden="true">MH</div>
    <div class="sr-only">Loading FUNTIMECHAT‚Ä¶</div>
  </div>

  <!-- Topbar -->
  <header id="topbar" role="banner">
    <div style="display:flex;align-items:center;gap:12px;">
      <div class="logo" id="app-logo">FUNTIMECHAT</div>
      <nav aria-label="Main nav">
        <ul style="display:flex;gap:10px;list-style:none;margin:0;padding:0">
          <li><button class="square-btn" data-view="home">Home</button></li>
          <li><button class="square-btn" data-view="social">Social</button></li>
          <li><button class="square-btn" data-view="chat">Rooms</button></li>
        </ul>
      </nav>
    </div>
    <div class="controls" style="display:flex;align-items:center">
      <button id="theme-toggle" title="Toggle dark">üåì</button>
      <button id="signout-btn" class="square-btn hidden">Sign out</button>
      <img id="profile-button" src="assets/logo.png" alt="Profile" class="profile-pic" />
    </div>
  </header>

  <!-- Main content -->
  <main id="main-content">
    <!-- AUTH -->
    <section id="auth-view" data-viewname="auth" class="view">
      <div class="auth-card" role="region" aria-label="Authentication">
        <h3>Welcome to FUNTIMECHAT</h3>
        <input id="display-name" placeholder="Display name" />
        <input id="email" type="email" placeholder="Email (optional)" />
        <input id="password" type="password" placeholder="Password (optional)" />
        <div style="display:flex;gap:8px">
          <button id="join-as-guest" class="square-btn type-b">Join as Guest</button>
          <button id="email-signup" class="square-btn">Sign up</button>
          <button id="email-signin" class="square-btn">Sign in</button>
        </div>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button id="google-signin" class="square-btn">Continue with Google</button>
          <button id="anon-signin" class="square-btn">Continue anonymously</button>
        </div>
        <p style="margin-top:10px">
          <a href="#" id="forgot-password-link">Forgot password?</a>
        </p>
      </div>
    </section>

    <!-- HOME -->
    <section id="home-view" data-viewname="home" class="view hidden">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3>Featured Rooms</h3>
        <div>
          <button id="quick-create-room" class="square-btn type-b">Create Room</button>
        </div>
      </div>
      <div id="featured-rooms" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px;margin-top:10px"></div>
      <h3 style="margin-top:14px">Social preview</h3>
      <div id="social-feed"></div>
    </section>

    <!-- SOCIAL -->
    <section id="social-view" data-viewname="social" class="view hidden">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3>Social Feed</h3>
        <button id="create-post" class="square-btn">Create Post</button>
      </div>
      <div id="social-list" style="margin-top:10px"></div>
    </section>

    <!-- PUBLIC CHAT -->
    <section id="public-chat-view" data-viewname="chat" class="view hidden" aria-live="polite">
      <div id="chat-layout" style="display:flex;gap:10px;align-items:stretch;">
        <aside id="chat-list-container" style="width:320px;min-width:220px;">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <h3>Rooms</h3>
            <button id="refresh-rooms" class="square-btn">Refresh</button>
          </div>
          <div id="rooms-list"></div>
        </aside>
        <section id="public-chat-area" style="flex:1;display:flex;flex-direction:column;">
          <div style="padding:12px;border-bottom:1px solid #eee;display:flex;justify-content:space-between;">
            <div>
              <strong id="active-room-name">Lobby</strong>
              <p id="active-room-sub" style="margin:0;color:var(--color-text-light)"></p>
            </div>
            <div>
              <button id="leave-room" class="square-btn">Leave</button>
            </div>
          </div>

          <div class="message-list-area" id="public-message-area" role="log"></div>

          <div id="typing-indicator-container" style="padding:6px 12px">
            <div class="typing-status hidden" id="typing-status">Someone is typing...</div>
          </div>

          <div class="input-area" role="form" aria-label="Send message">
            <input id="message-input" type="text" placeholder="Type a message..." />
            <button id="emoji-toggle">üòä</button>
            <button id="send-message" class="square-btn type-b">‚û§</button>
          </div>

          <div class="emoji-picker hidden" id="emoji-picker"></div>
        </section>
      </div>
    </section>

    <!-- INBOX / PM -->
    <section id="inbox-view" data-viewname="inbox" class="view hidden">
      <div style="display:flex;gap:10px;">
        <aside style="width:280px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <h3>Inbox</h3>
            <input id="friend-search-input" placeholder="Search friends" />
          </div>
          <div id="inbox-list"></div>
        </aside>
        <section id="private-chat-room" style="flex:1;display:flex;flex-direction:column;">
          <div style="padding:12px;border-bottom:1px solid #eee">
            <strong id="private-with">Select a chat</strong>
            <p id="private-status" style="margin:0;color:var(--color-text-light)"></p>
          </div>
          <div class="message-list-area" id="private-message-area"></div>
          <div class="input-area">
            <input id="private-message-input" placeholder="Type a private message..." />
            <button id="private-send" class="square-btn">‚û§</button>
          </div>
        </section>
      </div>
    </section>

    <!-- RANDOM MATCH -->
    <section id="random-view" data-viewname="random" class="view hidden">
      <div style="padding:12px">
        <h3>Random Chat</h3>
        <p>Anonymous matching ‚Äî press Start to join queue</p>
        <div style="display:flex;gap:8px">
          <button id="random-start" class="square-btn type-b">Start</button>
          <button id="random-skip" class="square-btn hidden">Next</button>
          <button id="random-stop" class="square-btn hidden">Stop</button>
        </div>

        <div id="random-chat-area" class="hidden" style="margin-top:12px">
          <div class="message-list-area" id="random-message-area"></div>
          <div class="input-area">
            <input id="random-message-input" placeholder="Send to matched user..." />
            <button id="random-send" class="square-btn">‚û§</button>
          </div>
        </div>
      </div>
    </section>

    <!-- ADMIN -->
    <section id="admin-view" data-viewname="admin" class="view hidden">
      <div style="padding:12px">
        <h3>Admin Panel</h3>
        <div>
          <button class="square-btn" id="admin-create-room">Create Room</button>
          <button class="square-btn" id="admin-view-reports">View Reports</button>
        </div>
        <div id="admin-console" style="margin-top:12px"></div>
      </div>
    </section>

  </main>

  <!-- CALL OVERLAY -->
  <div class="call-ui hidden" id="call-ui" aria-hidden="true">
    <h2>Call with <span id="call-with"></span></h2>
    <video id="remote-video" autoplay playsinline></video>
    <video id="local-video" autoplay muted playsinline></video>
    <div id="call-controls">
      <button id="end-call" class="square-btn type-b">End</button>
      <button id="mute-call" class="square-btn">Mute</button>
      <button id="toggle-camera" class="square-btn">Camera</button>
    </div>
  </div>

  <!-- Footer -->
  <footer id="legal-footer">
    <small>¬© <span id="year"></span> FUNTIMECHAT ‚Ä¢ <a href="#" id="terms-link">Terms</a> ‚Ä¢ <a href="#" id="privacy-link">Privacy</a></small>
  </footer>

  <!-- Bottom nav -->
  <nav id="bottom-nav" role="navigation">
    <button data-view="home">üè†<span style="font-size:0.7rem">Home</span></button>
    <button data-view="chat">üí¨<span style="font-size:0.7rem">Chat</span></button>
    <button data-view="social">üßë‚Äçü§ù‚Äçüßë<span style="font-size:0.7rem">Social</span></button>
    <button data-view="inbox">üì•<span style="font-size:0.7rem">Inbox</span></button>
    <button data-view="random">üîÄ<span style="font-size:0.7rem">Random</span></button>
  </nav>

  <!-- Profile dialog -->
  <dialog id="profile-modal">
    <form method="dialog">
      <div style="display:flex;gap:12px;align-items:center">
        <img src="assets/logo.png" alt="Profile" style="width:64px;height:64px;border-radius:50%" />
        <div>
          <h3 id="profile-username">Guest</h3>
          <p id="profile-bio" style="color:var(--color-text-light)">Bio</p>
        </div>
      </div>
      <div style="margin-top:8px">
        <input id="profile-edit-name" placeholder="Display name" />
        <input id="profile-edit-bio" placeholder="Short bio" />
        <input id="profile-photo" type="file" accept="image/*" />
      </div>
      <menu style="display:flex;gap:8px;justify-content:flex-end">
        <button id="save-profile" class="square-btn type-b">Save</button>
        <button id="close-profile" class="square-btn">Close</button>
      </menu>
    </form>
  </dialog>

  <!-- Audio assets (place into assets/) -->
  <audio id="msg-sound" src="assets/msg.mp3" preload="auto"></audio>
  <audio id="call-ringtone" src="assets/ringtone.mp3" preload="auto"></audio>

  <!-- Firebase + App Logic (single module script) -->
  <script type="module">
  /************************************************************************
   * IMPORTANT:
   * This script uses Firebase modular SDK via CDN. It initializes with
   * the exact firebaseConfig you provided. For production, secure your
   * Realtime DB and Storage rules after testing.
   ************************************************************************/

  // Firebase SDK imports (modular) - CDN versions (adjust version if needed)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import {
    getAuth, onAuthStateChanged, signInWithPopup, GoogleAuthProvider,
    createUserWithEmailAndPassword, signInWithEmailAndPassword,
    signOut, signInAnonymously, sendPasswordResetEmail, sendEmailVerification,
    updateProfile
  } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
  import {
    getDatabase, ref as dbRef, push, set, onChildAdded, onValue, update, remove, get, child, query, orderByChild, limitToLast, runTransaction
  } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
  import {
    getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL
  } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-storage.js";

  // Your Firebase config (from your pasted code)
  const firebaseConfig = {
    apiKey: "AIzaSyB__tJ3sv3cB2N3vKHFCv8SYngJENQxwhY",
    authDomain: "funtimechat69-39947.firebaseapp.com",
    databaseURL: "https://funtimechat69-39947-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "funtimechat69-39947",
    storageBucket: "funtimechat69-39947.firebasestorage.app",
    messagingSenderId: "559638056734",
    appId: "1:559638056734:web:9329d2b561b6fab106830f"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getDatabase(app);
  const storage = getStorage(app);

  // Basic state
  let currentUser = null;
  let currentRoom = 'lobby';
  let currentPrivateChatId = null;
  let randomMatchId = null;
  let localStream = null;
  let peerConnection = null; // placeholder for WebRTC

  // Short DOM refs
  const views = document.querySelectorAll('[data-viewname]');
  const bottomButtons = document.querySelectorAll('#bottom-nav button');
  const loadingScreen = document.getElementById('loading-screen');
  const yearEl = document.getElementById('year');
  yearEl.textContent = new Date().getFullYear();

  // ---------- UI helpers ----------
  function showView(name) {
    views.forEach(v => {
      const id = v.id || (v.dataset.viewname + '-view');
      if (v.dataset.viewname === name) v.classList.remove('hidden'); else v.classList.add('hidden');
    });
    bottomButtons.forEach(b => b.dataset.view === name ? b.classList.add('active') : b.classList.remove('active'));
  }

  document.querySelectorAll('[data-view]').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const view = btn.dataset.view;
      showView(view);
    });
  });
  bottomButtons.forEach(b => b.addEventListener('click', () => showView(b.dataset.view)));
  // default view set later after auth

  // ---------- Auth UI & logic ----------
  const joinGuestBtn = document.getElementById('join-as-guest');
  const googleSignBtn = document.getElementById('google-signin');
  const anonSignBtn = document.getElementById('anon-signin');
  const emailSignupBtn = document.getElementById('email-signup');
  const emailSigninBtn = document.getElementById('email-signin');
  const signoutBtn = document.getElementById('signout-btn');
  const forgotLink = document.getElementById('forgot-password-link');

  joinGuestBtn.addEventListener('click', async () => {
    const name = document.getElementById('display-name').value || 'Guest' + Math.floor(Math.random()*10000);
    // anonymous sign-in flow then set displayName
    try {
      const anon = await signInAnonymously(auth);
      await updateProfile(anon.user, { displayName: name });
      // create profile node
      await set(dbRef(db, 'users/' + anon.user.uid), { displayName: name, createdAt: Date.now() });
    } catch (err) {
      console.error('Anon sign-in failed', err);
      alert('Unable to sign in anonymously: ' + err.message);
    }
  });

  googleSignBtn.addEventListener('click', async () => {
    const provider = new GoogleAuthProvider();
    try {
      const res = await signInWithPopup(auth, provider);
      // create user entry if needed
      const u = res.user;
      await set(dbRef(db, 'users/' + u.uid), { displayName: u.displayName || 'User', photoURL: u.photoURL || null, lastSeen: Date.now() }, { merge: true });
    } catch (err) {
      console.error(err); alert('Google sign-in error: ' + err.message);
    }
  });

  emailSignupBtn.addEventListener('click', async () => {
    const email = document.getElementById('email').value;
    const pwd = document.getElementById('password').value;
    const display = document.getElementById('display-name').value || email.split('@')[0];
    if (!email || !pwd) return alert('Email and password required');
    try {
      const cred = await createUserWithEmailAndPassword(auth, email, pwd);
      await updateProfile(cred.user, { displayName: display });
      await set(dbRef(db, 'users/' + cred.user.uid), { displayName: display, email, createdAt: Date.now() });
      await sendEmailVerification(cred.user);
      alert('Account created, verification email sent.');
    } catch (err) { console.error(err); alert(err.message); }
  });

  emailSigninBtn.addEventListener('click', async () => {
    const email = document.getElementById('email').value;
    const pwd = document.getElementById('password').value;
    if (!email || !pwd) return alert('Provide email + password');
    try {
      await signInWithEmailAndPassword(auth, email, pwd);
    } catch (err) { console.error(err); alert('Sign in failed: ' + err.message); }
  });

  forgotLink.addEventListener('click', (e) => {
    e.preventDefault();
    const email = prompt('Enter your email to reset');
    if (!email) return;
    sendPasswordResetEmail(auth, email).then(() => alert('Reset email sent')).catch(err => alert(err.message));
  });

  signoutBtn.addEventListener('click', async () => {
    await signOut(auth);
  });

  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    if (user) {
      // update UI
      document.getElementById('profile-username').innerText = user.displayName || 'Guest';
      document.getElementById('profile-button').src = user.photoURL || 'assets/logo.png';
      document.getElementById('signout-btn').classList.remove('hidden');
      // write presence
      await set(dbRef(db, 'presence/' + user.uid), { online: true, lastSeen: Date.now() });
      // show home
      showView('home');
      loadingScreen.style.display = 'none';
      // load initial data
      loadFeaturedRooms();
      watchRooms();
      restoreInbox();
    } else {
      // not logged in
      document.getElementById('signout-btn').classList.add('hidden');
      showView('auth');
      loadingScreen.style.display = 'none';
    }
  });

  // cleanup presence on unload
  window.addEventListener('beforeunload', () => {
    if (currentUser) set(dbRef(db, 'presence/' + currentUser.uid), { online: false, lastSeen: Date.now() });
  });

  // ---------- Rooms (Public Chat) ----------
  async function loadFeaturedRooms() {
    const demo = ['lobby','gaming','music','anime','random'];
    const container = document.getElementById('featured-rooms');
    container.innerHTML = '';
    demo.forEach(r => {
      const card = document.createElement('article');
      card.className = 'chat-list-item';
      card.innerHTML = `<div><strong>${r}</strong><p style="margin:4px 0 0;color:var(--color-text-light)">Active users: -</p></div><div style="align-self:center"><button class="square-btn" data-join="${r}">Join</button></div>`;
      container.appendChild(card);
    });
  }

  document.addEventListener('click', async (ev) => {
    if (ev.target.matches('[data-join]')) {
      const room = ev.target.dataset.join;
      joinRoom(room);
    }
  });

  async function watchRooms() {
    // load available rooms from /rooms (if you store them)
    const roomsRef = dbRef(db, 'rooms');
    onValue(roomsRef, snap => {
      const list = document.getElementById('rooms-list');
      list.innerHTML = '';
      const val = snap.val() || {};
      // if no rooms, create default
      if (!Object.keys(val).length) {
        ['lobby','gaming','music'].forEach(async (r) => {
          await set(dbRef(db, 'rooms/' + r), { name: r, createdAt: Date.now() });
        });
      }
      Object.keys(val).forEach(k => {
        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.innerHTML = `<div><h3>${val[k].name}</h3><p>${val[k].meta || ''}</p></div><div><button class="square-btn" data-join="${val[k].name}">Join</button></div>`;
        list.appendChild(item);
      });
    });
  }

  // join public room
  async function joinRoom(roomName) {
    currentRoom = roomName;
    document.getElementById('active-room-name').innerText = roomName;
    document.getElementById('public-message-area').innerHTML = '';
    // listen for messages on /roomsMessages/{roomName}
    const roomMessagesRef = dbRef(db, 'roomMessages/' + roomName);
    onChildAdded(roomMessagesRef, (snap) => {
      const msg = snap.val();
      renderPublicMessage(snap.key, msg);
    });
    // auto scroll behaviour
  }

  // send public message:
  document.getElementById('send-message').addEventListener('click', sendPublicMessage);
  document.getElementById('message-input').addEventListener('keydown', (e) => { if (e.key === 'Enter') sendPublicMessage(); });

  async function sendPublicMessage() {
    const txt = document.getElementById('message-input').value.trim();
    if (!txt || !currentUser) return;
    const payload = {
      uid: currentUser.uid,
      name: currentUser.displayName || 'Guest',
      text: txt,
      createdAt: Date.now(),
      type: 'text',
      seenBy: { [currentUser.uid]: true }
    };
    const pushRef = await push(dbRef(db, 'roomMessages/' + currentRoom), payload);
    document.getElementById('message-input').value = '';
    // play sound + notification
    document.getElementById('msg-sound').play().catch(()=>{});
  }

  function renderPublicMessage(id, msg) {
    const area = document.getElementById('public-message-area');
    const card = document.createElement('div');
    card.className = 'message-card ' + (msg.uid === (currentUser && currentUser.uid) ? 'outgoing' : 'incoming') + (msg.seen ? ' seen' : '');
    const time = new Date(msg.createdAt || Date.now());
    const timeStr = `${time.getHours()}:${String(time.getMinutes()).padStart(2,'0')}`;
    card.innerHTML = `<div class="message-header"><span>${escapeHtml(msg.name || 'User')}</span><span>${timeStr}</span></div><div class="message-body">${escapeHtml(msg.text || '')}</div><div class="message-status-ticks">${msg.seen ? '‚úì‚úì' : '‚úì'}</div>`;
    area.appendChild(card);
    area.scrollTop = area.scrollHeight;
  }

  // typing indicator (basic)
  const messageInput = document.getElementById('message-input');
  let typingTimeout = null;
  messageInput.addEventListener('input', () => {
    if (!currentUser) return;
    set(dbRef(db, `typing/${currentRoom}/${currentUser.uid}`), { name: currentUser.displayName || 'User', ts: Date.now() });
    clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => {
      remove(dbRef(db, `typing/${currentRoom}/${currentUser.uid}`));
    }, 2500);
  });

  // listen for typing
  onValue(dbRef(db, 'typing/' + currentRoom), snap => {
    const val = snap.val();
    if (!val) {
      document.getElementById('typing-status').classList.add('hidden'); return;
    }
    const keys = Object.keys(val);
    if (keys.length) {
      const first = val[keys[0]];
      document.getElementById('typing-status').innerText = `${first.name} is typing...`;
      document.getElementById('typing-status').classList.remove('hidden');
    } else document.getElementById('typing-status').classList.add('hidden');
  });

  // ---------- Private messages (PM) ----------
  function getPMId(a,b) {
    // deterministic order
    return [a,b].sort().join('_');
  }

  async function openPrivateChat(otherUid, otherName) {
    currentPrivateChatId = getPMId(currentUser.uid, otherUid);
    document.getElementById('private-with').innerText = otherName;
    document.getElementById('private-message-area').innerHTML = '';
    // listen messages
    const pmRef = dbRef(db, 'pm/' + currentPrivateChatId);
    onChildAdded(pmRef, snap => {
      const msg = snap.val();
      const card = document.createElement('div');
      card.className = 'message-card ' + (msg.uid === currentUser.uid ? 'outgoing' : 'incoming');
      const t = new Date(msg.createdAt || Date.now());
      card.innerHTML = `<div class="message-header"><span>${escapeHtml(msg.name)}</span><span>${t.getHours()}:${String(t.getMinutes()).padStart(2,'0')}</span></div><div class="message-body">${escapeHtml(msg.text)}</div>`;
      document.getElementById('private-message-area').appendChild(card);
      document.getElementById('private-message-area').scrollTop = document.getElementById('private-message-area').scrollHeight;
    });
  }

  document.getElementById('private-send').addEventListener('click', async () => {
    const text = document.getElementById('private-message-input').value.trim();
    if (!text || !currentPrivateChatId) return;
    const payload = { uid: currentUser.uid, name: currentUser.displayName || 'User', text, createdAt: Date.now() };
    await push(dbRef(db, 'pm/' + currentPrivateChatId), payload);
    document.getElementById('private-message-input').value = '';
  });

  async function restoreInbox() {
    // simple scan: find all PM nodes where currentUser is participant (this is a naive approach; index rules better)
    // We'll watch friendRequests and pm summaries node
    const inboxList = document.getElementById('inbox-list');
    inboxList.innerHTML = '';
    const summariesRef = dbRef(db, 'pmSummaries/' + (currentUser ? currentUser.uid : 'anon'));
    onValue(summariesRef, snap => {
      inboxList.innerHTML = '';
      const val = snap.val() || {};
      Object.keys(val).forEach(k => {
        const item = val[k];
        const div = document.createElement('div');
        div.className = 'chat-list-item';
        div.innerHTML = `<div><h3>${escapeHtml(item.name)}</h3><p>Last: ${escapeHtml(item.last || '')}</p></div><div><button class="square-btn" data-open="${k}">Open</button></div>`;
        inboxList.appendChild(div);
      });
    });
  }

  // open pm from inbox
  document.addEventListener('click', (e) => {
    if (e.target.matches('[data-open]')) {
      const otherUid = e.target.dataset.open;
      // lookup user's displayName
      get(child(dbRef(db), 'users/' + otherUid)).then(s => {
        const data = s.val() || {};
        openPrivateChat(otherUid, data.displayName || 'User');
      });
    }
  });

  // ---------- Random Match (Omegle style) ----------
  const randomStartBtn = document.getElementById('random-start');
  const randomSkipBtn = document.getElementById('random-skip');
  const randomStopBtn = document.getElementById('random-stop');

  randomStartBtn.addEventListener('click', async () => {
    if (!currentUser) return alert('Login required');
    // push into matchQueue with uid + ts
    const qRef = dbRef(db, 'matchQueue');
    const myRef = await push(qRef, { uid: currentUser.uid, ts: Date.now(), anon: true });
    // listen for match assignment on userMatches/{myUid}
    const myKey = myRef.key;
    // simple pairing logic: try to find another waiting user
    const snap = await get(qRef);
    const val = snap.val() || {};
    // naive immediate match: pick first other
    const otherKey = Object.keys(val).find(k => k !== myKey);
    if (otherKey) {
      // create match
      const otherUid = val[otherKey].uid;
      const matchId = [currentUser.uid, otherUid].sort().join('_');
      await set(dbRef(db, 'userMatches/' + matchId), { users: { [currentUser.uid]: true, [otherUid]: true }, startedAt: Date.now() });
      // remove both queue entries
      await remove(dbRef(db, 'matchQueue/' + myKey));
      await remove(dbRef(db, 'matchQueue/' + otherKey));
      // open a temporary random chat
      startRandomChat(matchId, otherUid);
    } else {
      // wait - listen for other pushing
      const unwatch = onChildAdded(qRef, async (snap) => {
        const data = snap.val();
        const k = snap.key;
        if (k !== myKey) {
          const matchId = [currentUser.uid, data.uid].sort().join('_');
          await set(dbRef(db, 'userMatches/' + matchId), { users: { [currentUser.uid]: true, [data.uid]: true }, startedAt: Date.now() });
          // remove both
          await remove(dbRef(db, 'matchQueue/' + myKey));
          await remove(dbRef(db, 'matchQueue/' + k));
          unwatch(); // stop listening
          startRandomChat(matchId, data.uid);
        }
      });
    }
  });

  function startRandomChat(matchId, otherUid) {
    randomMatchId = matchId;
    document.getElementById('random-chat-area').classList.remove('hidden');
    document.getElementById('random-start').classList.add('hidden');
    document.getElementById('random-skip').classList.remove('hidden');
    // attach listener to node /random/{matchId}
    const rndRef = dbRef(db, 'random/' + matchId);
    onChildAdded(rndRef, snap => {
      const m = snap.val();
      const area = document.getElementById('random-message-area');
      const el = document.createElement('div');
      el.className = 'message-card ' + (m.uid === currentUser.uid ? 'outgoing' : 'incoming');
      el.innerHTML = `<div class="message-body">${escapeHtml(m.text)}</div>`;
      area.appendChild(el);
      area.scrollTop = area.scrollHeight;
    });
  }

  document.getElementById('random-send').addEventListener('click', async () => {
    const txt = document.getElementById('random-message-input').value.trim();
    if (!txt || !randomMatchId) return;
    await push(dbRef(db, 'random/' + randomMatchId), { uid: currentUser.uid, text: txt, createdAt: Date.now() });
    document.getElementById('random-message-input').value = '';
  });

  document.getElementById('random-skip').addEventListener('click', async () => {
    // end match and attempt new one (naive)
    if (randomMatchId) {
      await remove(dbRef(db, 'random/' + randomMatchId));
      randomMatchId = null;
      document.getElementById('random-chat-area').classList.add('hidden');
      document.getElementById('random-start').classList.remove('hidden');
      document.getElementById('random-skip').classList.add('hidden');
      document.getElementById('random-stop').classList.add('hidden');
    }
  });

  // ---------- WebRTC call placeholders (signaling via DB) ----------
  // Note: Full WebRTC requires STUN/TURN and more code. This is a starter skeleton.
  async function startCallWith(uid) {
    if (!currentUser) return alert('Login required');
    const callId = push(dbRef(db, 'calls')).key;
    // create call node with offer placeholders
    await set(dbRef(db, 'calls/' + callId), { from: currentUser.uid, to: uid, status: 'ringing', ts: Date.now() });
    // UI show ringing
    document.getElementById('call-with').innerText = uid;
    document.getElementById('call-ui').classList.remove('hidden');
    // further WebRTC steps would create RTCPeerConnection, createOffer, setLocalDescription, and put SDP in dbRef(db,'webrtc/'+callId+'/offer')
  }

  document.getElementById('end-call').addEventListener('click', async () => {
    document.getElementById('call-ui').classList.add('hidden');
    // cleanup peerConnection + streams
    if (peerConnection) { peerConnection.close(); peerConnection = null; }
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
  });

  // ---------- Media upload (images/files) ----------
  document.getElementById('profile-photo').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file || !currentUser) return;
    const path = `uploads/${currentUser.uid}/profile/${Date.now()}_${file.name}`;
    const sRef = storageRef(storage, path);
    const uploadTask = uploadBytesResumable(sRef, file);
    uploadTask.on('state_changed', snapshot => {}, err => { alert('Upload failed: '+err.message); }, async () => {
      const url = await getDownloadURL(uploadTask.snapshot.ref);
      await updateProfile(currentUser, { photoURL: url });
      await update(dbRef(db, 'users/' + currentUser.uid), { photoURL: url });
      document.getElementById('profile-button').src = url;
    });
  });

  // send image in public chat (drag/drop or file input can be added)
  async function sendImageToRoom(file) {
    const path = `uploads/${currentUser.uid}/messages/${Date.now()}_${file.name}`;
    const sRef = storageRef(storage, path);
    const uploadTask = uploadBytesResumable(sRef, file);
    uploadTask.on('state_changed', snap => {}, err => alert(err.message), async () => {
      const url = await getDownloadURL(uploadTask.snapshot.ref);
      const payload = { uid: currentUser.uid, name: currentUser.displayName || 'User', text: '', media: { url, name: file.name, size: file.size }, createdAt: Date.now() };
      await push(dbRef(db, 'roomMessages/' + currentRoom), payload);
    });
  }

  // ---------- Safety: block / report / simple bad word filter ----------
  const BAD_WORDS = ['badword1','badword2']; // simple client filter - extend server-side
  function containsBadWord(text) {
    const t = text.toLowerCase();
    return BAD_WORDS.some(w => t.includes(w));
  }

  async function reportUser(uid, reason) {
    const rRef = push(dbRef(db, 'reports'));
    await set(rRef, { reportedUid: uid, by: currentUser ? currentUser.uid : 'anon', reason, ts: Date.now() });
  }

  // admin actions (very basic)
  async function adminBanUser(uid) {
    await set(dbRef(db, 'banned/' + uid), { bannedAt: Date.now(), by: currentUser ? currentUser.uid : 'admin' });
  }

  // ---------- Friends system skeleton ----------
  async function sendFriendRequest(toUid) {
    const reqRef = push(dbRef(db, `friendRequests/${toUid}`));
    await set(reqRef, { from: currentUser.uid, ts: Date.now() });
  }

  async function acceptFriendRequest(fromUid) {
    await set(dbRef(db, `friends/${currentUser.uid}/${fromUid}`), { since: Date.now() });
    await set(dbRef(db, `friends/${fromUid}/${currentUser.uid}`), { since: Date.now() });
    // remove request (add logic to find and remove)
  }

  // ---------- Notifications ----------
  function notify(title, body) {
    if (Notification.permission === 'granted') {
      new Notification(title, { body });
    } else if (Notification.permission !== 'denied') {
      Notification.requestPermission().then(p => { if (p === 'granted') new Notification(title, { body }); });
    }
  }

  // play incoming message sound
  function playMsgSound() {
    const s = document.getElementById('msg-sound');
    s.play().catch(()=>{});
  }

  // ---------- Admin console (UI hooks) ----------
  document.getElementById('admin-view')?.addEventListener('click', () => {
    // fill admin console with reports/rooms
    // For brevity, read reports
    get(dbRef(db, 'reports')).then(snap => {
      const val = snap.val() || {};
      const c = document.getElementById('admin-console');
      c.innerHTML = '<h4>Reports</h4>';
      Object.keys(val).forEach(k => {
        const r = val[k];
        const d = document.createElement('div');
        d.innerHTML = `<div><strong>${r.reportedUid}</strong> - ${r.reason} <button class="square-btn" data-ban="${r.reportedUid}">Ban</button></div>`;
        c.appendChild(d);
      });
    });
  });

  document.addEventListener('click', (e) => {
    if (e.target.matches('[data-ban]')) {
      const uid = e.target.dataset.ban;
      adminBanUser(uid);
      alert('Banned ' + uid);
    }
  });

  // ---------- Utility ----------
  function escapeHtml(str='') {
    return String(str).replace(/[&<>"'`=\/]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;','`':'&#x60;'}[s]));
  }

  // ---------- Initial UI wiring ----------
  // Emoji picker populate simple set
  const emojis = ['üòÄ','üòÇ','üòç','üëç','üéâ','üî•','üò¢','ü§Ø','üòé','üôå','ü§ù','üí¨'];
  const emojiPicker = document.getElementById('emoji-picker');
  emojis.forEach(e => {
    const b = document.createElement('button'); b.type='button'; b.textContent = e;
    b.addEventListener('click', () => {
      const input = document.getElementById('message-input');
      input.value += e;
      input.focus();
    });
    emojiPicker.appendChild(b);
  });
  document.getElementById('emoji-toggle').addEventListener('click', () => {
    emojiPicker.classList.toggle('hidden');
  });

  // quick create room
  document.getElementById('quick-create-room').addEventListener('click', async () => {
    const name = prompt('Room name:','new-room');
    if (!name) return;
    await set(dbRef(db, 'rooms/' + name), { name, createdAt: Date.now() });
  });

  // When a room is joined we already attach onChildAdded in joinRoom
  // small convenience: join default lobby if authenticated
  // show/hide auth view handled by onAuthStateChanged earlier

  // Simple message receive notification
  onChildAdded(dbRef(db, 'roomMessages/lobby'), (snap) => {
    const m = snap.val();
    if (currentUser && m.uid !== currentUser.uid) {
      notify('New message in lobby', `${m.name}: ${m.text || '[media]'}`);
      playMsgSound();
    }
  });

  // end of module
  </script>

</body>
</html>
