<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FUNTIMECHAT</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div id="loading-screen" class="screen active">
        <div class="logo-pulse">MH</div> <p>Loading FunTimeChat...</p>
    </div>

    <div id="app-container" style="display:none;">

        <header id="topbar">
            <div class="logo">MH</div>
            <h1 id="current-view-title">Welcome</h1>
            <div class="controls">
                <button id="theme-toggle">â˜€ï¸/ğŸŒ™</button>
                <button id="admin-panel-btn" style="display:none;">ğŸ”‘ Admin</button>
                <img id="user-photo" src="default.png" alt="Profile" class="profile-pic" style="display:none;">
                <button id="signout-btn" style="display:none;">Logout</button>
            </div>
        </header>

        <main id="main-content">
            <div id="auth-view" class="view active">
                <h2>Sign In / Sign Up</h2>
                <div class="auth-card">
                    <button id="google-signin-btn" class="square-btn type-b">Sign in with Google</button>
                    <hr>
                    <input type="email" id="email-input" placeholder="Email">
                    <input type="password" id="password-input" placeholder="Password">
                    <button id="email-signin-btn" class="square-btn type-b">Sign In</button>
                    <button id="email-signup-btn" class="square-btn type-b">Sign Up</button>
                    <button id="forgot-password-btn">Forgot Password?</button>
                    <button id="anonymous-login-btn">Continue as Guest</button>
                </div>
            </div>

            <div id="public-chat-view" class="view" style="display:none;">
                <div class="room-selector">
                    <button class="square-btn type-b active-room">Global Chat</button>
                </div>
                <div id="messages-container" class="message-list-area">
                    </div>
                <div id="typing-indicator" class="typing-status" style="display:none;">Someone is typing...</div>
                <div class="input-area">
                    <input type="text" id="message-input" placeholder="Type a message...">
                    <input type="file" id="public-file-upload-input" style="display:none;">
                    <button id="public-upload-file-btn">ğŸ“</button>
                    <button id="send-message-btn" class="square-btn type-b">â¡ï¸</button>
                </div>
            </div>

            <div id="inbox-view" class="view" style="display:none;">
                <button id="back-to-inbox-list" class="square-btn type-b" style="display:none; width:auto; margin-bottom: 10px;">â† Back to Inbox</button>
                <h2 id="inbox-title">Private Messages (Inbox)</h2>
                <div id="chat-list-container" class="message-list-area">
                    <p>Loading your private chats...</p>
                </div>
                <div id="private-chat-room" style="display:none; height:100%; display:flex; flex-direction:column;">
                    <div id="chat-header-controls" style="display:flex; justify-content:space-between; align-items:center; padding-bottom:10px; border-bottom:1px solid #eee;">
                        <span id="chat-partner-name" style="font-weight:bold;"></span>
                        <div class="call-buttons">
                            <button id="start-audio-call-btn" class="square-btn type-b" style="width: auto; padding: 5px 10px; margin: 0 5px;">ğŸ“ Audio</button>
                            <button id="start-video-call-btn" class="square-btn type-b" style="width: auto; padding: 5px 10px; margin: 0 0;">ğŸ“¹ Video</button>
                        </div>
                    </div>
                    <div id="private-messages-container" class="message-list-area" style="flex-grow:1; height: auto;"></div>
                    <div class="input-area">
                        <input type="text" id="private-message-input" placeholder="Type private message...">
                        <input type="file" id="private-file-upload-input" style="display:none;">
                        <button id="private-upload-file-btn">ğŸ“</button>
                        <button id="private-send-message-btn" class="square-btn type-b">â¡ï¸</button>
                    </div>
                </div>
            </div>

            <div id="random-chat-view" class="view" style="display:none;">
                <h2>Random Chat</h2>
                <p>Click 'Start Match' to find a stranger!</p>
                <button id="start-random-match-btn" class="square-btn type-b">Start Match</button>
            </div>
            
            <div id="friends-view" class="view" style="display:none;">
                <h2>Friends & Requests</h2>
                
                <div class="search-area" style="margin-bottom: 20px;">
                    <input type="text" id="friend-search-input" placeholder="Search user by display name or email part...">
                    <button id="friend-search-btn" class="square-btn type-b">ğŸ” Search</button>
                </div>
                <div id="search-results-container" style="margin-bottom: 20px;"></div>

                <h3 style="border-bottom: 1px solid #ccc; padding-bottom: 5px;">Friend Requests</h3>
                <div id="requests-container" class="message-list-area" style="max-height: 200px; overflow-y: auto; margin-bottom: 20px;">
                    <p>No new requests.</p>
                </div>

                <h3 style="border-bottom: 1px solid #ccc; padding-bottom: 5px;">My Friends</h3>
                <div id="friends-list-container" class="message-list-area" style="flex-grow: 1; overflow-y: auto;">
                    <p>Your friend list is empty. Find users using the search bar above!</p>
                </div>
            </div>
            <div id="admin-view" class="view" style="display:none;">
                <h2>ğŸ”‘ Admin Dashboard</h2>
                <p>Manage users and global content.</p>
                <div class="admin-panel-tabs">
                    <button class="square-btn type-b active-tab" data-tab="users-tab">Users</button>
                    <button class="square-btn type-b" data-tab="public-chat-tab">Public Chat</button>
                </div>
                
                <div id="users-tab" class="admin-tab-content active">
                    <h3>Registered Users</h3>
                    <div id="admin-users-list" class="message-list-area">
                        <p>Loading user list...</p>
                    </div>
                </div>
                
                <div id="public-chat-tab" class="admin-tab-content" style="display:none;">
                    <h3>Public Messages</h3>
                    <div id="admin-public-messages" class="message-list-area">
                        <p>Loading messages...</p>
                    </div>
                </div>
            </div>
            </main>

        <div id="call-overlay" class="call-ui" style="display:none;">
            <h2 id="call-status">Connecting...</h2>
            <video id="local-video" autoplay muted style="width:100%; max-height:200px; background:#000;"></video>
            <video id="remote-video" autoplay style="width:100%; max-height:400px; background:#000;"></video>
            <div id="call-controls">
                <button id="end-call-btn" class="square-btn type-b" style="background:#dc3545;">ğŸ”´ End Call</button>
                <button id="accept-call-btn" class="square-btn type-b" style="background:#28a745; display:none;">âœ… Accept</button>
                <button id="reject-call-btn" class="square-btn type-b" style="background:#dc3545; display:none;">âŒ Reject</button>
            </div>
        </div>

        <nav id="bottom-nav">
            <button data-view="public-chat-view">ğŸ’¬ Public</button>
            <button data-view="inbox-view">âœ‰ï¸ Inbox</button>
            <button data-view="random-chat-view">ğŸ² Random</button>
            <button data-view="friends-view">ğŸ‘¥ Friends</button>
        </nav>

        <footer id="legal-footer">
            <a href="privacy.html">Privacy Policy</a> | <a href="terms.html">Terms</a> | <a href="report.html">Report</a>
        </footer>
    </div>

    <audio id="new-message-sound" src="message.mp3" preload="auto"></audio>
    <audio id="incoming-call-ringtone" src="ringtone.mp3" preload="auto"></audio>

    <script type="module">
        // ğŸš¨ STEP 1: Firebase Configuration (Your Code)
        const firebaseConfig = {
            apiKey: "AIzaSyB__tJ3sv3cB2N3vKHFCv8SYngJENQxwhY",
            authDomain: "funtimechat69-39947.firebaseapp.com",
            databaseURL: "https://funtimechat69-39947-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "funtimechat69-39947",
            storageBucket: "funtimechat69-39947.appspot.com", 
            messagingSenderId: "559638056734",
            appId: "1:559638056734:web:9329d2b561b6fab106830f"
        };

        // ğŸš¨ STEP 2: Necessary Firebase SDK Imports 
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { 
            getAuth, signInWithPopup, GoogleAuthProvider, createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, sendPasswordResetEmail, onAuthStateChanged, 
            signOut, signInAnonymously, updateProfile 
        } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
        import { 
            getDatabase, ref, push, onValue, serverTimestamp, query, limitToLast, set, remove, off, get, update
        } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
        import { 
            getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL 
        } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";

        // Initialize Firebase Services
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);
        const storage = getStorage(app);

        // Global variables for Admin status
        let currentUserIsAdmin = false;
        
        // Utility function to switch views
        const handleNavigation = (viewId) => {
            document.querySelectorAll('.view').forEach(view => {
                view.style.display = 'none';
            });
            const newView = document.getElementById(viewId);
            if(newView) {
                newView.style.display = 'block';
                document.getElementById('current-view-title').textContent = newView.querySelector('h2')?.textContent || 'FunTimeChat';
            }
        };

        // ***************************************************************
        // 8. NOTIFICATION SYSTEM (NEW LOGIC)
        // ***************************************************************
        
        // ğŸ’¡ FUNCTION: à¤¬à¥à¤°à¤¾à¤‰à¤œà¤¼à¤° à¤¨à¥‹à¤Ÿà¤¿à¤«à¤¿à¤•à¥‡à¤¶à¤¨ à¤•à¥‡ à¤²à¤¿à¤ à¤…à¤¨à¥à¤®à¤¤à¤¿ à¤®à¤¾à¤‚à¤—à¤¨à¤¾
        const requestNotificationPermission = () => {
            if (Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log("Notification permission granted.");
                    }
                });
            }
        };

        // ğŸ’¡ FUNCTION: à¤à¤• à¤¨à¤¯à¤¾ à¤¨à¥‹à¤Ÿà¤¿à¤«à¤¿à¤•à¥‡à¤¶à¤¨ à¤¦à¤¿à¤–à¤¾à¤¨à¤¾
        const showNotification = (title, body) => {
            document.getElementById('new-message-sound').play().catch(e => console.log("Sound play failed:", e));

            if (Notification.permission === 'granted' && document.hidden) {
                new Notification(title, {
                    body: body,
                    icon: 'default.png',
                    vibrate: [200, 100, 200]
                });
            }
        };
        
        // ğŸ’¡ FUNCTION: User data save (Checks and updates admin status)
        const saveUserData = async (user) => {
            if (user && !user.isAnonymous) {
                const userRef = ref(db, `users/${user.uid}`);
                const userData = {
                    displayName: user.displayName || user.email?.split('@')[0] || 'User',
                    email: user.email || 'N/A',
                    photoURL: user.photoURL || 'default.png',
                    lastActive: serverTimestamp()
                };

                await set(userRef, userData, { merge: true }).catch(e => console.error("Error saving user data:", e));

                // Check Admin Status
                const snapshot = await get(userRef);
                const isAdmin = snapshot.val()?.isAdmin || false;
                currentUserIsAdmin = isAdmin; 
                document.getElementById('admin-panel-btn').style.display = isAdmin ? 'block' : 'none';
            }
        };

        // ***************************************************************
        // 2. ACCOUNT SYSTEM (AUTHENTICATION) - ACTIVE
        // ***************************************************************

        // Auth State Listener (Handles Login/Logout UI)
        onAuthStateChanged(auth, (user) => {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('app-container').style.display = 'flex'; 

            const userPhotoEl = document.getElementById('user-photo');
            const signoutBtn = document.getElementById('signout-btn');
            const adminBtn = document.getElementById('admin-panel-btn');

            if (user) {
                document.getElementById('auth-view').style.display = 'none';
                userPhotoEl.style.display = 'block';
                signoutBtn.style.display = 'block';
                adminBtn.style.display = 'none'; // Will be set correctly inside saveUserData

                userPhotoEl.src = user.photoURL || 'default.png';
                
                if(document.getElementById('public-chat-view').style.display === 'none' && document.getElementById('auth-view').style.display === 'block') {
                    handleNavigation('public-chat-view');
                }
                
                // CORE INTEGRATION CALLS
                saveUserData(user); // Now asynchronous
                requestNotificationPermission(); // Point 8
                loadChatList();
                loadFriendsData();
                setupCallListener(user.uid);
            } else {
                currentUserIsAdmin = false;
                document.getElementById('auth-view').style.display = 'block';
                userPhotoEl.style.display = 'none';
                signoutBtn.style.display = 'none';
                adminBtn.style.display = 'none';
                
                handleNavigation('auth-view');
            }
        });
        
        // [Existing Auth Code...]
        document.getElementById('google-signin-btn').addEventListener('click', async () => {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                alert("Google Sign-in failed: " + error.message);
            }
        });
        
        document.getElementById('email-signup-btn').addEventListener('click', async () => {
            const email = document.getElementById('email-input').value;
            const password = document.getElementById('password-input').value;
            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                await updateProfile(userCredential.user, { displayName: email.split('@')[0] }); 
                alert("Sign Up successful! Logged in.");
            } catch (error) {
                alert("Sign Up failed: " + error.message);
            }
        });

        document.getElementById('email-signin-btn').addEventListener('click', async () => {
            const email = document.getElementById('email-input').value;
            const password = document.getElementById('password-input').value;
            try {
                await signInWithEmailAndPassword(auth, email, password);
                alert("Sign In successful!");
            } catch (error) {
                alert("Sign In failed: " + error.message);
            }
        });

        document.getElementById('anonymous-login-btn').addEventListener('click', async () => {
            try {
                await signInAnonymously(auth);
                alert("Signed in as Guest.");
            } catch (error) {
                alert("Anonymous Sign-in failed: " + error.message);
            }
        });

        document.getElementById('forgot-password-btn').addEventListener('click', async () => {
            const email = document.getElementById('email-input').value;
            if (email) {
                try {
                    await sendPasswordResetEmail(auth, email);
                    alert("Password reset email sent!");
                } catch (error) {
                    alert("Error sending reset email: " + error.message);
                }
            } else {
                alert("Please enter your email in the field above.");
            }
        });
        
        document.getElementById('signout-btn').addEventListener('click', async () => {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Logout Error:", error);
            }
        });

        // ***************************************************************
        // 3. PUBLIC CHAT SYSTEM (ACTIVE SEND/RECEIVE)
        // ***************************************************************

        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendMessageBtn = document.getElementById('send-message-btn');
        const publicFileUploadInput = document.getElementById('public-file-upload-input');
        const publicUploadFileBtn = document.getElementById('public-upload-file-btn');
        const messagesRef = ref(db, 'public_rooms/global/messages');
        const recentMessagesQuery = query(messagesRef, limitToLast(100)); 

        const updateMessageSeenStatus = (messageKey, roomType, chatID) => {
            const currentUser = auth.currentUser;
            if (!currentUser) return;

            const path = roomType === 'public' 
                ? `public_rooms/global/messages/${messageKey}/reads/${currentUser.uid}`
                : `private_chats/${chatID}/messages/${messageKey}/reads/${currentUser.uid}`;
                
            set(ref(db, path), true)
                .catch(error => console.error("Error setting seen status:", error));
        };
        
        const renderMessage = (message, key, roomType, chatID, container) => {
            const currentUserUid = auth.currentUser?.uid;
            
            const reads = message.reads || {};
            const allUids = Object.keys(reads);
            
            let seenStatus = 'delivered'; 
            let seenCount = allUids.length - 1; 

            if (message.uid === currentUserUid) {
                if (seenCount >= 1) {
                    seenStatus = 'seen'; 
                } 
            } else {
                seenStatus = 'received';
                if (!reads[currentUserUid]) {
                    setTimeout(() => updateMessageSeenStatus(key, roomType, chatID), 500);
                }
            }

            const messageElement = document.createElement('div');
            messageElement.className = `message-card ${seenStatus}`; 
            
            let contentHTML = '';
            if (message.fileURL && message.fileType) {
                if (message.fileType.startsWith('image/')) {
                    contentHTML = `<img src="${message.fileURL}" alt="Shared Image" style="max-width: 100%; height: auto; border-radius: 8px;">`;
                } else if (message.fileType.startsWith('video/')) {
                    contentHTML = `<video src="${message.fileURL}" controls style="max-width: 100%; height: auto; border-radius: 8px;"></video>`;
                } else {
                    contentHTML = `<a href="${message.fileURL}" target="_blank" style="color: var(--link-color);">â¬‡ï¸ Download File: ${message.text || message.fileType}</a>`;
                }
            }
            
            if (message.text) {
                contentHTML += `<p class="message-text">${message.text}</p>`;
            } else if (!message.fileURL) {
                contentHTML += `<p class="message-text">[Empty Message]</p>`;
            }

            messageElement.innerHTML = `
                <div class="message-header">
                    <span class="user-name">${message.displayName || 'Anonymous'}</span>
                    <span class="timestamp">${new Date(message.timestamp).toLocaleTimeString()}</span>
                </div>
                ${contentHTML}
                <div class="message-status-ticks">
                    ${message.uid === currentUserUid ? (seenStatus === 'seen' ? 'âœ”ï¸âœ”ï¸' : 'âœ”ï¸') : ''}
                </div>
            `;
            messageElement.dataset.key = key; 
            container.appendChild(messageElement);
        };

        const sendChatMessage = async (containerRef, messageText, fileURL, fileType) => {
            const currentUser = auth.currentUser;
            if (!currentUser || (!messageText.trim() && !fileURL)) {
                alert("Message cannot be empty.");
                return;
            }

            const initialReads = {};
            initialReads[currentUser.uid] = true; 

            try {
                await push(containerRef, {
                    uid: currentUser.uid,
                    displayName: currentUser.displayName || 'Guest',
                    text: messageText,
                    fileURL: fileURL || null,
                    fileType: fileType || null,
                    timestamp: serverTimestamp(),
                    reads: initialReads, 
                });
            } catch (e) {
                console.error("Error sending message: ", e);
            }
        };

        // Sending Text Message Logic (Public Chat)
        sendMessageBtn.addEventListener('click', async () => {
            const messageText = messageInput.value.trim();
            if (messageText) {
                await sendChatMessage(messagesRef, messageText, null, null);
                messageInput.value = '';
            } else {
                alert("Please type a message or upload a file first.");
            }
        });

        // Receiving Messages Logic (Public Chat) - UPDATED FOR NOTIFICATION
        onValue(recentMessagesQuery, (snapshot) => {
            const lastMessageKey = snapshot.val() ? Object.keys(snapshot.val()).pop() : null;
            let lastMessage = null;

            messagesContainer.innerHTML = ''; 
            snapshot.forEach((childSnapshot) => {
                const message = childSnapshot.val();
                renderMessage(message, childSnapshot.key, 'public', null, messagesContainer);
                if (childSnapshot.key === lastMessageKey) {
                    lastMessage = message;
                }
            });
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            if (lastMessage && lastMessage.uid !== auth.currentUser?.uid) {
                 const messageBody = lastMessage.text || (lastMessage.fileType.startsWith('image/') ? '[Image]' : '[File]');
                 showNotification(`New Global Message from ${lastMessage.displayName}`, messageBody);
            }
        });
        
        // ***************************************************************
        // 4. PRIVATE CHAT (INBOX) SYSTEM (ACTIVE LOGIC)
        // ***************************************************************
        
        const chatListContainer = document.getElementById('chat-list-container');
        const privateMessagesContainer = document.getElementById('private-messages-container');
        const privateMessageInput = document.getElementById('private-message-input');
        const privateSendMessageBtn = document.getElementById('private-send-message-btn');
        const privateFileUploadInput = document.getElementById('private-file-upload-input');
        const privateUploadFileBtn = document.getElementById('private-upload-file-btn');
        const backToInboxBtn = document.getElementById('back-to-inbox-list');
        const privateChatRoom = document.getElementById('private-chat-room');
        const chatPartnerNameEl = document.getElementById('chat-partner-name');
        
        let currentChatID = null; 
        let currentOtherUid = null; 
        let privateMessageListener = null; 

        const loadChatList = () => {
            if (!auth.currentUser) return;
            const chatsRef = ref(db, 'private_chats');

            onValue(chatsRef, async (snapshot) => {
                chatListContainer.innerHTML = '';
                let hasChats = false;

                snapshot.forEach(async (childSnapshot) => {
                    const chat = childSnapshot.val();
                    const chatID = childSnapshot.key;
                    
                    if (chat.participants && chat.participants[auth.currentUser.uid]) {
                        hasChats = true;
                        
                        const otherUid = Object.keys(chat.participants).find(uid => uid !== auth.currentUser.uid);
                        const otherDisplayName = chat.participants[otherUid]?.displayName || 'Stranger';
                        
                        const lastMessageSnapshot = await get(query(ref(db, `private_chats/${chatID}/messages`), limitToLast(1)));
                        let lastMessageText = 'Start chatting!';
                        
                        lastMessageSnapshot.forEach(msgSnap => {
                            const msg = msgSnap.val();
                            if (msg.fileURL) {
                                lastMessageText = msg.fileType.startsWith('image/') ? 'ğŸ“· Image' : (msg.fileType.startsWith('video/') ? 'ğŸ“¹ Video' : 'ğŸ“ File');
                            } else {
                                lastMessageText = msg.text;
                            }
                        });

                        const chatItem = document.createElement('div');
                        chatItem.className = 'chat-list-item'; 
                        chatItem.dataset.chatID = chatID;
                        chatItem.dataset.otherUid = otherUid; 
                        chatItem.dataset.otherName = otherDisplayName;
                        chatItem.innerHTML = `
                            <h3>${otherDisplayName}</h3>
                            <p>${lastMessageText.substring(0, 30)}...</p>
                            <span class="chat-time">${new Date(chat.createdAt).toLocaleDateString()}</span>
                        `;
                        
                        chatItem.addEventListener('click', () => openPrivateChat(chatID, otherUid, otherDisplayName));
                        
                        chatListContainer.appendChild(chatItem);
                    }
                });
                
                if (!hasChats) {
                    chatListContainer.innerHTML = '<p>Your inbox is empty. Try starting a Random Chat or add a Friend!</p>';
                }
            });
        };

        // ğŸ’¡ FUNCTION: à¤à¤• à¤ªà¥à¤°à¤¾à¤‡à¤µà¥‡à¤Ÿ à¤šà¥ˆà¤Ÿ à¤°à¥‚à¤® à¤–à¥‹à¤²à¤¨à¤¾ (UPDATED FOR NOTIFICATION)
        const openPrivateChat = (chatID, otherUid, otherName) => {
            currentChatID = chatID;
            currentOtherUid = otherUid; 
            
            document.getElementById('inbox-title').textContent = `Chatting with ${otherName}`;
            chatPartnerNameEl.textContent = otherName; 
            chatListContainer.style.display = 'none';
            privateChatRoom.style.display = 'flex';
            backToInboxBtn.style.display = 'block';
            
            privateMessagesContainer.innerHTML = ''; 
            
            if (privateMessageListener) {
                off(privateMessageListener);
            }

            const messagesRef = ref(db, `private_chats/${chatID}/messages`);
            const recentMessagesQuery = query(messagesRef, limitToLast(100)); 

            privateMessageListener = onValue(recentMessagesQuery, (snapshot) => {
                const lastMessageKey = snapshot.val() ? Object.keys(snapshot.val()).pop() : null;
                let lastMessage = null;

                privateMessagesContainer.innerHTML = '';
                snapshot.forEach((childSnapshot) => {
                    const message = childSnapshot.val();
                    renderMessage(message, childSnapshot.key, 'private', chatID, privateMessagesContainer);
                    if (childSnapshot.key === lastMessageKey) {
                        lastMessage = message;
                    }
                });
                privateMessagesContainer.scrollTop = privateMessagesContainer.scrollHeight;

                if (lastMessage && lastMessage.uid !== auth.currentUser?.uid && privateChatRoom.style.display === 'flex' && document.hidden) {
                    const messageBody = lastMessage.text || (lastMessage.fileType.startsWith('image/') ? '[Image]' : '[File]');
                    showNotification(`New Message from ${otherName}`, messageBody);
                }
            });
        };


        // ğŸ’¡ EVENT: à¤ªà¥à¤°à¤¾à¤‡à¤µà¥‡à¤Ÿ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤®à¥ˆà¤¸à¥‡à¤œ à¤­à¥‡à¤œà¤¨à¤¾
        privateSendMessageBtn.addEventListener('click', async () => {
            const messageText = privateMessageInput.value.trim();
            if (messageText && currentChatID) {
                const messagesRef = ref(db, `private_chats/${currentChatID}/messages`);
                await sendChatMessage(messagesRef, messageText, null, null);
                privateMessageInput.value = '';
            } else {
                alert("Please type a message or upload a file first.");
            }
        });

        // ğŸ’¡ EVENT: Inbox List à¤ªà¤° à¤µà¤¾à¤ªà¤¸ à¤œà¤¾à¤¨à¤¾
        backToInboxBtn.addEventListener('click', () => {
            currentChatID = null;
            currentOtherUid = null;
            if (privateMessageListener) {
                off(privateMessageListener); 
            }
            
            document.getElementById('inbox-title').textContent = 'Private Messages (Inbox)';
            chatListContainer.style.display = 'block';
            privateChatRoom.style.display = 'none';
            backToInboxBtn.style.display = 'none';
        });

        // ***************************************************************
        // 5. RANDOM CHAT SYSTEM (ACTIVE LOGIC)
        // ***************************************************************
        
        // [Existing Random Chat Logic is correct]
        const randomChatBtn = document.querySelector('#bottom-nav button[data-view="random-chat-view"]');
        const randomChatView = document.getElementById('random-chat-view');
        let currentMatchListener = null; 
        const createNewRandomChat = (user1Uid, user2Uid) => {
            const chatID = [user1Uid, user2Uid].sort().join('_');
            const chatRef = ref(db, `private_chats/${chatID}`);
            const queueRef = ref(db, 'matchQueue');
            get(ref(db, `matchQueue/${user2Uid}`)).then((snapshot) => {
                const otherDisplayName = snapshot.val()?.displayName || 'Stranger';
                set(chatRef, {
                    participants: {
                        [user1Uid]: { displayName: auth.currentUser.displayName || 'User' },
                        [user2Uid]: { displayName: otherDisplayName } 
                    },
                    status: 'active',
                    createdAt: serverTimestamp()
                })
                .then(() => {
                    alert(`Match Found! You are now connected with ${otherDisplayName}. Check your Inbox.`);
                    randomChatView.innerHTML = `<h2>Random Chat</h2><p>Match Found with ${otherDisplayName}! Go to your Inbox to start chatting.</p><button id="start-random-match-btn" class="square-btn type-b">Start New Match</button>`;
                    handleNavigation('inbox-view'); 
                    loadChatList(); 
                })
                .catch(error => console.error("Error creating chat:", error));
                remove(ref(db, `matchQueue/${user1Uid}`));
                remove(ref(db, `matchQueue/${user2Uid}`));
            });
        };

        const startRandomMatchmaking = async () => {
            const currentUser = auth.currentUser;
            if (!currentUser || currentUser.isAnonymous) {
                alert("Please sign in with a permanent account to start Random Chat.");
                return;
            }
            randomChatView.innerHTML = `<h2>Searching for a Match...</h2><p>Please wait while we connect you with a stranger.</p><button id="cancel-match-btn" class="square-btn type-b">Cancel Matchmaking</button>`;
            handleNavigation('random-chat-view');
            const queueRef = ref(db, 'matchQueue');
            await set(ref(db, `matchQueue/${currentUser.uid}`), {
                displayName: currentUser.displayName || 'Stranger',
                timestamp: serverTimestamp()
            });
            document.getElementById('cancel-match-btn').addEventListener('click', () => {
                remove(ref(db, `matchQueue/${currentUser.uid}`));
                if (currentMatchListener) {
                    off(currentMatchListener); 
                }
                randomChatView.innerHTML = `<h2>Random Chat</h2><p>Matchmaking cancelled. Click 'Start Match' to try again.</p><button id="start-random-match-btn" class="square-btn type-b">Start Match</button>`;
                document.getElementById('start-random-match-btn').addEventListener('click', startRandomMatchmaking);
            });
            const findMatch = onValue(queueRef, (snapshot) => {
                const queue = snapshot.val();
                if (!queue) return;
                const uidsInQueue = Object.keys(queue);
                if (uidsInQueue.length >= 2) {
                    const potentialMatchUid = uidsInQueue.find(uid => uid !== currentUser.uid);
                    if (potentialMatchUid) {
                        off(findMatch);
                        createNewRandomChat(currentUser.uid, potentialMatchUid);
                    }
                }
            });
            currentMatchListener = findMatch; 
        };

        randomChatBtn.addEventListener('click', () => {
            if (auth.currentUser) {
                startRandomMatchmaking();
            } else {
                alert("Please sign in to use Random Chat.");
                handleNavigation('auth-view');
            }
        });

        document.getElementById('random-chat-view').addEventListener('click', (e) => {
            if (e.target.id === 'start-random-match-btn') {
                startRandomMatchmaking();
            }
        });

        // ***************************************************************
        // 6. AUDIO/VIDEO CALLS (WebRTC) - ACTIVE LOGIC
        // ***************************************************************
        
        // [Existing Call Logic is correct]
        const callOverlay = document.getElementById('call-overlay');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const callStatusEl = document.getElementById('call-status');
        let pc = null; 
        let localStream = null; 
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ],
        };

        const startCall = async (videoEnabled) => {
            if (!currentOtherUid) return alert("Error: No recipient found.");
            try {
                const constraints = { video: videoEnabled, audio: true };
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;
            } catch (error) {
                console.error("Error getting user media:", error);
                alert("Cannot access camera/mic. Check permissions.");
                return;
            }
            callOverlay.style.display = 'flex';
            callStatusEl.textContent = videoEnabled ? "Video Calling..." : "Audio Calling...";
            document.getElementById('accept-call-btn').style.display = 'none';
            document.getElementById('reject-call-btn').style.display = 'none';
            document.getElementById('end-call-btn').style.display = 'block';
            pc = new RTCPeerConnection(iceServers);
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            pc.ontrack = (event) => {
                remoteVideo.srcObject = event.streams[0];
            };
            const callRef = ref(db, `calls/${currentOtherUid}`); 
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    await push(ref(db, `calls/${currentOtherUid}/iceCandidates`), {
                        candidate: event.candidate.toJSON(),
                        senderUid: auth.currentUser.uid
                    });
                }
            };
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await set(callRef, {
                callerUid: auth.currentUser.uid,
                callerName: auth.currentUser.displayName || 'User',
                offer: pc.localDescription.toJSON(),
                callType: videoEnabled ? 'video' : 'audio',
                timestamp: serverTimestamp(),
                status: 'ringing'
            });
            callStatusEl.textContent = `Ringing ${chatPartnerNameEl.textContent}...`;
            document.getElementById('incoming-call-ringtone').play();
        };

        const answerCall = async (callData, callKey) => {
            const isVideoCall = callData.callType === 'video';
            try {
                const constraints = { video: isVideoCall, audio: true };
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;
            } catch (error) {
                console.error("Error getting user media:", error);
                alert("Cannot access camera/mic. Check permissions.");
                endCall();
                return;
            }
            callOverlay.style.display = 'flex';
            callStatusEl.textContent = "Connecting...";
            document.getElementById('accept-call-btn').style.display = 'none';
            document.getElementById('reject-call-btn').style.display = 'none';
            document.getElementById('end-call-btn').style.display = 'block';
            document.getElementById('incoming-call-ringtone').pause();
            pc = new RTCPeerConnection(iceServers);
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            pc.ontrack = (event) => {
                remoteVideo.srcObject = event.streams[0];
                callStatusEl.textContent = "Call Connected!";
            };
            const answerRef = ref(db, `calls/${callData.callerUid}`); 
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    await push(ref(db, `calls/${callData.callerUid}/iceCandidates`), {
                        candidate: event.candidate.toJSON(),
                        senderUid: auth.currentUser.uid
                    });
                }
            };
            await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await update(answerRef, {
                answer: pc.localDescription.toJSON(),
                status: 'answered'
            });
            onValue(ref(db, `calls/${auth.currentUser.uid}/iceCandidates`), (snapshot) => {
                snapshot.forEach(async (childSnapshot) => {
                    const candidateData = childSnapshot.val();
                    if (candidateData.senderUid !== auth.currentUser.uid) {
                        try {
                            await pc.addIceCandidate(new RTCIceCandidate(candidateData.candidate));
                        } catch (e) {
                            console.error("Error adding ICE candidate:", e);
                        }
                    }
                });
            });
            remove(ref(db, `calls/${auth.currentUser.uid}`));
        };

        const endCall = () => {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (pc) {
                pc.close();
                pc = null;
            }
            remove(ref(db, `calls/${auth.currentUser.uid}`));
            callOverlay.style.display = 'none';
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            document.getElementById('incoming-call-ringtone').pause();
        };

        // ğŸ’¡ Call Listener (UPDATED FOR NOTIFICATION)
        const setupCallListener = (uid) => {
            const receiverRef = ref(db, `calls/${uid}`);

            onValue(receiverRef, async (snapshot) => {
                const callData = snapshot.val();
                
                if (callData && callData.status === 'ringing' && callData.callerUid !== uid) {
                    // Show notification/alert for incoming call (Point 8)
                    showNotification(`Incoming Call`, `New ${callData.callType} call from ${callData.callerName}!`);
                    
                    callOverlay.style.display = 'flex';
                    callStatusEl.textContent = `Incoming ${callData.callType} call from ${callData.callerName}...`;
                    document.getElementById('end-call-btn').style.display = 'none';
                    document.getElementById('accept-call-btn').style.display = 'block';
                    document.getElementById('reject-call-btn').style.display = 'block';
                    document.getElementById('incoming-call-ringtone').play();
                    
                    document.getElementById('accept-call-btn').onclick = () => answerCall(callData, snapshot.key);
                    document.getElementById('reject-call-btn').onclick = () => {
                        update(receiverRef, { status: 'rejected' });
                        endCall();
                    };
                } 
                
                else if (callData && callData.status === 'answered' && callData.answer && pc) {
                    await pc.setRemoteDescription(new RTCSessionDescription(callData.answer));
                    callStatusEl.textContent = "Call Connected!";
                    onValue(ref(db, `calls/${uid}/iceCandidates`), (snapshot) => {
                        snapshot.forEach(async (childSnapshot) => {
                            const candidateData = childSnapshot.val();
                            if (candidateData.senderUid !== auth.currentUser.uid) {
                                try {
                                    await pc.addIceCandidate(new RTCIceCandidate(candidateData.candidate));
                                } catch (e) {
                                    console.error("Error adding ICE candidate:", e);
                                }
                            }
                        });
                    });
                } else if (callData && callData.status === 'rejected') {
                    alert(`${callData.callerName} rejected your call.`);
                    endCall();
                } else if (!callData && pc) {
                    alert("Call ended.");
                    endCall();
                }
            });
        };
        
        document.getElementById('start-audio-call-btn').addEventListener('click', () => startCall(false));
        document.getElementById('start-video-call-btn').addEventListener('click', () => startCall(true));
        document.getElementById('end-call-btn').addEventListener('click', endCall);


        // ***************************************************************
        // 7. FRIENDS SYSTEM (ACTIVE LOGIC)
        // ***************************************************************
        
        // [Existing Friends Logic is correct]
        const friendSearchInput = document.getElementById('friend-search-input');
        const friendSearchBtn = document.getElementById('friend-search-btn');
        const searchResultsContainer = document.getElementById('search-results-container');
        const requestsContainer = document.getElementById('requests-container');
        const friendsListContainer = document.getElementById('friends-list-container');
        const usersRef = ref(db, 'users'); 

        const searchUser = async () => {
            const searchTerm = friendSearchInput.value.trim().toLowerCase();
            searchResultsContainer.innerHTML = '';
            if (searchTerm.length < 3) {
                searchResultsContainer.innerHTML = '<p>Enter at least 3 characters to search.</p>';
                return;
            }
            const snapshot = await get(usersRef);
            if (!snapshot.exists()) return;
            const users = snapshot.val();
            const currentUid = auth.currentUser.uid;
            let found = false;
            Object.keys(users).forEach(uid => {
                const user = users[uid];
                const displayName = user.displayName?.toLowerCase() || '';
                const email = user.email?.toLowerCase() || '';
                if (uid !== currentUid && (displayName.includes(searchTerm) || email.includes(searchTerm))) {
                    found = true;
                    const friendItem = document.createElement('div');
                    friendItem.className = 'chat-list-item'; 
                    friendItem.innerHTML = `
                        <h3>${user.displayName || user.email}</h3>
                        <p>UID: ${uid.substring(0, 8)}...</p>
                        <button class="send-request-btn square-btn type-b" data-uid="${uid}">+ Add Friend</button>
                    `;
                    searchResultsContainer.appendChild(friendItem);
                }
            });
            if (!found) {
                searchResultsContainer.innerHTML = '<p>No users found matching your search.</p>';
            }
        };
        friendSearchBtn.addEventListener('click', searchUser);

        const sendFriendRequest = async (targetUid) => {
            const currentUser = auth.currentUser;
            if (!currentUser || targetUid === currentUser.uid) return;
            const requestRef = ref(db, `user_friends/${targetUid}/requests/${currentUser.uid}`);
            await set(requestRef, {
                senderName: currentUser.displayName || currentUser.email,
                timestamp: serverTimestamp()
            });
            alert(`Friend request sent to user ${targetUid.substring(0, 8)}...`);
            const btn = document.querySelector(`.send-request-btn[data-uid="${targetUid}"]`);
            if(btn) btn.textContent = 'Request Sent';
            if(btn) btn.disabled = true;
        };

        searchResultsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('send-request-btn')) {
                const targetUid = e.target.dataset.uid;
                sendFriendRequest(targetUid);
            }
        });

        const acceptFriendRequest = async (senderUid, senderName) => {
            const currentUser = auth.currentUser;
            if (!currentUser) return;
            const currentUserName = currentUser.displayName || currentUser.email;
            const chatID = [currentUser.uid, senderUid].sort().join('_');
            await set(ref(db, `user_friends/${currentUser.uid}/friends/${senderUid}`), {
                displayName: senderName,
                timestamp: serverTimestamp(),
                chatID: chatID
            });
            await set(ref(db, `user_friends/${senderUid}/friends/${currentUser.uid}`), {
                displayName: currentUserName,
                timestamp: serverTimestamp(),
                chatID: chatID
            });
            await remove(ref(db, `user_friends/${currentUser.uid}/requests/${senderUid}`));
            const chatRef = ref(db, `private_chats/${chatID}`);
            await set(chatRef, {
                participants: {
                    [currentUser.uid]: { displayName: currentUserName },
                    [senderUid]: { displayName: senderName } 
                },
                status: 'active',
                createdAt: serverTimestamp()
            });
            alert(`${senderName} is now your friend!`);
        };

        const rejectFriendRequest = async (senderUid) => {
            const currentUser = auth.currentUser;
            if (!currentUser) return;
            await remove(ref(db, `user_friends/${currentUser.uid}/requests/${senderUid}`));
        };

        const loadFriendsData = () => {
            const currentUser = auth.currentUser;
            if (!currentUser || currentUser.isAnonymous) return;
            const userFriendsRef = ref(db, `user_friends/${currentUser.uid}`);

            onValue(ref(userFriendsRef, 'requests'), (snapshot) => {
                requestsContainer.innerHTML = '';
                if (!snapshot.exists()) {
                    requestsContainer.innerHTML = '<p>No new requests.</p>';
                    return;
                }
                snapshot.forEach(childSnapshot => {
                    const senderUid = childSnapshot.key;
                    const request = childSnapshot.val();
                    const requestItem = document.createElement('div');
                    requestItem.className = 'chat-list-item'; 
                    requestItem.innerHTML = `
                        <h3>${request.senderName}</h3>
                        <div style="display:flex; gap:5px;">
                            <button class="accept-request-btn square-btn type-b" data-uid="${senderUid}" data-name="${request.senderName}">âœ… Accept</button>
                            <button class="reject-request-btn square-btn type-b" data-uid="${senderUid}">âŒ Reject</button>
                        </div>
                    `;
                    requestsContainer.appendChild(requestItem);
                });
            });
            
            onValue(ref(userFriendsRef, 'friends'), (snapshot) => {
                friendsListContainer.innerHTML = '';
                if (!snapshot.exists()) {
                    friendsListContainer.innerHTML = '<p>Your friend list is empty. Find users using the search bar above!</p>';
                    return;
                }
                snapshot.forEach(childSnapshot => {
                    const friendUid = childSnapshot.key;
                    const friend = childSnapshot.val();
                    const friendItem = document.createElement('div');
                    friendItem.className = 'chat-list-item friend-item'; 
                    friendItem.dataset.chatID = friend.chatID; 
                    friendItem.dataset.otherUid = friendUid;
                    friendItem.dataset.otherName = friend.displayName;
                    friendItem.innerHTML = `
                        <h3>${friend.displayName}</h3>
                        <p>Friend since: ${new Date(friend.timestamp).toLocaleDateString()}</p>
                        <button class="square-btn type-b" style="width: auto; padding: 5px 10px;">âœ‰ï¸ Chat</button>
                    `;
                    friendItem.addEventListener('click', () => {
                        handleNavigation('inbox-view');
                        openPrivateChat(friend.chatID, friendUid, friend.displayName);
                    });
                    friendsListContainer.appendChild(friendItem);
                });
            });
        };

        requestsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('accept-request-btn')) {
                const senderUid = e.target.dataset.uid;
                const senderName = e.target.dataset.name;
                acceptFriendRequest(senderUid, senderName);
            } else if (e.target.classList.contains('reject-request-btn')) {
                const senderUid = e.target.dataset.uid;
                rejectFriendRequest(senderUid);
            }
        });


        // ***************************************************************
        // 10. MEDIA SHARING (UPLOAD/SEND) - ACTIVE LOGIC
        // ***************************************************************

        // Helper function to handle file upload to Firebase Storage
        const uploadFileAndSend = (file, messageText, messagesRef, inputElement) => {
            if (!file) {
                alert("No file selected.");
                return;
            }
            const currentUser = auth.currentUser;
            if (!currentUser) {
                alert("You must be logged in to upload files.");
                return;
            }

            const fileName = `${Date.now()}_${file.name}`;
            const fileType = file.type;
            const storagePath = `chat_media/${currentUser.uid}/${fileName}`;
            const uploadTask = uploadBytesResumable(storageRef(storage, storagePath), file);

            uploadTask.on('state_changed', 
                (snapshot) => {
                    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                    console.log(`Upload is ${progress}% done`);
                    inputElement.placeholder = `Uploading: ${Math.round(progress)}%...`;
                }, 
                (error) => {
                    console.error("Upload failed:", error);
                    alert("File upload failed: " + error.message);
                    inputElement.value = ''; // Reset file input
                    inputElement.placeholder = "Type a message...";
                }, 
                () => {
                    getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {
                        console.log('File available at', downloadURL);
                        sendChatMessage(messagesRef, messageText, downloadURL, fileType)
                            .then(() => {
                                inputElement.value = ''; // Reset file input
                                inputElement.placeholder = "Type a message...";
                            });
                    });
                }
            );
        };

        // --- PUBLIC CHAT MEDIA LOGIC ---
        publicUploadFileBtn.addEventListener('click', () => {
            publicFileUploadInput.click();
        });

        publicFileUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const messageText = prompt("Add a caption (optional):") || '';
                uploadFileAndSend(file, messageText, messagesRef, messageInput); // messageInput is the main input element for placeholder
            }
        });

        // --- PRIVATE CHAT MEDIA LOGIC ---
        privateUploadFileBtn.addEventListener('click', () => {
            if (!currentChatID) {
                alert("Please select a private chat room first.");
                return;
            }
            privateFileUploadInput.click();
        });

        privateFileUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && currentChatID) {
                const messagesRef = ref(db, `private_chats/${currentChatID}/messages`);
                const messageText = prompt("Add a caption (optional):") || '';
                uploadFileAndSend(file, messageText, messagesRef, privateMessageInput); // privateMessageInput is the main input element
            } else if (file) {
                alert("Please select a private chat room first.");
            }
        });
        
        // ***************************************************************
        // 9. ADMIN PANEL (NEW ACTIVE LOGIC)
        // ***************************************************************

        // ğŸ’¡ FUNCTION: à¤¯à¥‚à¤œà¤¼à¤°à¥à¤¸ à¤•à¥€ à¤²à¤¿à¤¸à¥à¤Ÿ à¤²à¥‹à¤¡ à¤•à¤°à¤¨à¤¾
        const loadAdminUsers = () => {
            const adminUsersList = document.getElementById('admin-users-list');
            onValue(usersRef, (snapshot) => {
                adminUsersList.innerHTML = '';
                snapshot.forEach(childSnapshot => {
                    const user = childSnapshot.val();
                    const uid = childSnapshot.key;
                    
                    const userItem = document.createElement('div');
                    userItem.className = 'chat-list-item'; 
                    userItem.innerHTML = `
                        <h3>${user.displayName || user.email} ${user.isAdmin ? '(ADMIN ğŸ‘‘)' : ''}</h3>
                        <p>UID: ${uid.substring(0, 8)}...</p>
                        <div style="display:flex; gap:5px;">
                            <button class="square-btn type-b" onclick="alert('Functionality to Block/Ban user: ${uid}')">ğŸš« Block</button>
                            <button class="square-btn type-b" style="background:#dc3545;" onclick="deleteUser(${uid})">ğŸ—‘ï¸ Delete Data</button>
                        </div>
                    `;
                    adminUsersList.appendChild(userItem);
                });
            });
        };
        
        // ğŸ’¡ FUNCTION: à¤ªà¤¬à¥à¤²à¤¿à¤• à¤®à¥ˆà¤¸à¥‡à¤œ à¤²à¤¿à¤¸à¥à¤Ÿ à¤²à¥‹à¤¡ à¤•à¤°à¤¨à¤¾
        const loadAdminPublicMessages = () => {
            const adminPublicMessages = document.getElementById('admin-public-messages');
            const limitedMessagesQuery = query(messagesRef, limitToLast(50));
            
            onValue(limitedMessagesQuery, (snapshot) => {
                adminPublicMessages.innerHTML = '';
                snapshot.forEach(childSnapshot => {
                    const message = childSnapshot.val();
                    const messageKey = childSnapshot.key;
                    
                    const msgItem = document.createElement('div');
                    msgItem.className = 'message-card'; 
                    msgItem.innerHTML = `
                        <p><strong>${message.displayName} (${message.uid.substring(0, 4)}...)</strong>:</p>
                        <p>${message.text || (message.fileURL ? `[File: ${message.fileType}]` : '[Empty]')}</p>
                        <button class="square-btn type-b" style="background:#dc3545; padding: 5px 10px;" 
                                onclick="deletePublicMessage('${messageKey}')">âŒ Delete Message</button>
                    `;
                    adminPublicMessages.appendChild(msgItem);
                });
            });
        };

        // ğŸ’¡ GLOBAL FUNCTION: à¤®à¥ˆà¤¸à¥‡à¤œ à¤¡à¤¿à¤²à¥€à¤Ÿ à¤•à¤°à¤¨à¤¾ (Admin only)
        window.deletePublicMessage = (messageKey) => {
            if (!currentUserIsAdmin) {
                alert("ACCESS DENIED: You are not authorized to perform this action.");
                return;
            }
            if (confirm(`Are you sure you want to delete message ${messageKey}?`)) {
                remove(ref(db, `public_rooms/global/messages/${messageKey}`))
                    .then(() => alert("Message deleted successfully."))
                    .catch(e => alert("Error deleting message: " + e.message));
            }
        };

        // ğŸ’¡ GLOBAL FUNCTION: à¤¯à¥‚à¤œà¤¼à¤° à¤¡à¥‡à¤Ÿà¤¾ à¤¡à¤¿à¤²à¥€à¤Ÿ à¤•à¤°à¤¨à¤¾ (Admin only - only DB entry)
        window.deleteUser = (uid) => {
             if (!currentUserIsAdmin) {
                alert("ACCESS DENIED: You are not authorized to perform this action.");
                return;
            }
            if (confirm(`Are you sure you want to delete all data for UID: ${uid}? (This only removes DB data, not Auth user)`)) {
                // Delete user's profile and friend data
                remove(ref(db, `users/${uid}`));
                remove(ref(db, `user_friends/${uid}`));
                alert("User data removed from Realtime DB. (Manual deletion in Firebase Auth is required).");
            }
        }
        
        // Admin Panel Button Listener
        document.getElementById('admin-panel-btn').addEventListener('click', () => {
            if (currentUserIsAdmin) {
                handleNavigation('admin-view');
                loadAdminUsers();
                loadAdminPublicMessages(); 
            } else {
                alert("Access Denied.");
            }
        });
        
        // Admin Panel Tab Switching
        document.querySelector('.admin-panel-tabs').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.tab) {
                document.querySelectorAll('.admin-tab-content').forEach(tab => tab.style.display = 'none');
                document.querySelector('.admin-panel-tabs .active-tab')?.classList.remove('active-tab');
                
                document.getElementById(e.target.dataset.tab).style.display = 'block';
                e.target.classList.add('active-tab');
            }
        });


        // ***************************************************************
        // UI AND NAVIGATION (Point 1)
        // ***************************************************************

        // Bottom Navigation Handler
        document.getElementById('bottom-nav').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.view) {
                if (auth.currentUser || e.target.dataset.view === 'auth-view') {
                    handleNavigation(e.target.dataset.view);
                } else {
                    alert("Please sign in first!");
                }
            }
        });
        
        // Dark/Light Toggle Placeholder
        document.getElementById('theme-toggle').addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
        });
    </script>
</body>
</html>
